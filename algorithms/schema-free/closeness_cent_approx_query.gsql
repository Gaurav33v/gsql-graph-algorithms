CREATE QUERY closeness_approx (
    SET<STRING> v_type, 
    SET<STRING> e_type,
		int k,  # sample num
		int maxHops,  # max BFS explore steps 
		double epsilon,  # error parameter
    		bool print_accum, # output to console
		string file_path,  # output file 
		int debug,  # debug flag -- 0: No LOG;1: LOG without the sample-node bfs loop;2: ALL LOG.
		int sample_index,  # random sample group
		int maxsize,  # max size of connected components using exact closeness algorithm
		bool wf = True # Wasserman and Faust formula 
) {
		
		MinAccum<int> @cc_id;      # each vertex's tentative component id
		MapAccum<int,int> @@cc_size;    # component size 
		MapAccum<vertex,int> @@cc_map;   # closeness centrality of each node
		SumAccum<int> @vid;  # internal id
		SumAccum<int> @deltav;  # the distance from the pivot
		SumAccum<int> @@curDist,@@dist;  # the distance of BFS algorithm 
		MaxAccum<vertex> @pivot;  # the pivot of the node
		SetAccum<vertex> @@sample;  # sample node set
		OrAccum<bool> @sampled;  # sample node
		OrAccum<bool> @visited,@visited0;  # visited node in BFS
		SumAccum<int> @@totalDist;  # the sum distance of the sample node
		SumAccum<int> @@nonsample;  # the size of non-sample node in the visiting node
		MapAccum<vertex,int> @@cdist;  # the shortest distance between the sample node
		AvgAccum @lavg; # LAVG: the average distance from the sample node within the threshold radius
		SumAccum<int> @hcsum; # HCSUM: the sum distance from the sample node outside the threshold radius
		SumAccum<int> @sdist; # record the distance when the sample node cannot be decided
		SumAccum<int> @lnum; # number of nodes within the threshold radius
		SumAccum<int> @hsum; # HSUM: the sum distance from non sample node outside the threshold radius
		SumAccum<float> @totalDist; # the sum distance of the nodes
		SumAccum<float> @closeness; # the closeness centrality
		FILE f(file_path);
		
		int numVert,partition,i;
		datetime t1,t2;
	  float eps = 0.00001;
	
		Start = {v_type};
		LOG(debug > 0,"query start",Start.size());
		
		# Total number of nodes
    numVert = Start.size();
	
		# Initialize: Label each vertex with its own internal ID
		comp = SELECT x FROM Start:x
			POST-ACCUM x.@cc_id = getvid(x);

		# Propagate smaller internal IDs until no more ID changes can be DOne
		WHILE (comp.size()>0) DO
			comp = SELECT t FROM comp:s-(e_type)->:t
				ACCUM t.@cc_id += s.@cc_id 	// If s has a smaller id than t, copy the id to t
	            HAVING t.@cc_id != t.@cc_id';
		END;
		LOG(debug > 0,"find connected components");
	  
		# get components size
		Start = select s from Start:s
	        post-accum @@cc_size += (s.@cc_id->1);
		LOG(debug > 0,"size of connected components",@@cc_size.size());
	
		foreach (cc_id,cc_num) in @@cc_size do			
			Conn = select s from Start:s
					where s.@cc_id == cc_id;
			
			if cc_num < maxsize then
				# for small components, get exact closeness centrality for each vertex
				Conn = SELECT s FROM Conn:s
						ACCUM s.@closeness = closeness_approx_sub(s,v_type,e_type,numVert,maxHops,wf);
			else
				# for large components, get estimate closeness centrality for each vertex
				# partition size
				if cc_num % k == 0 then
					partition = cc_num/k;
				else 
					partition = cc_num/k + 1;
				end;
	  
				# sampling
				snode = select s from Conn:s
						accum s.@vid += getvid(s)
						having s.@vid % partition == sample_index
						limit k;
				i = sample_index;
				while snode.size() < k do
					i = (i + 1) % partition;
					snode = select s from Conn:s
							having s.@vid % partition == i
							limit k;
				end;
	
				snode = select s from snode:s
						accum s.@sampled += True,
						@@sample += s;
				LOG(debug > 0, "sampling finished", snode.size());
				print snode.size();		
		
				# Set all sample node as the starting point
        @@curDist = 0;
				src = select s from snode:s
					accum s.@pivot += s,
					s.@deltav += @@curDist,
          s.@visited0 += True;
				LOG(debug > 0, "initialize pivot query", src.size());
		
				# BFS: get the pivot of all nodes and its distance from the pivot
				while src.size() > 0 do
					@@curDist += 1;
					src = select t from src:s-(e_type)->:t
						where t.@visited0 == False
						accum 
							t.@pivot += s.@pivot
            post-accum
              t.@visited0 += True,
							t.@deltav = @@curDist;
				end;
				LOG(debug > 0, "pivot query finished", @@curDist);
		
				# run BFS from each sample node
				foreach sample_node in @@sample do
					# set one sample node as starting node
          LOG(debug > 1,"one sample_node begin");
					vnode = {sample_node};
			
					vnode = select s from vnode:s
							accum s.@visited += True;
			
					# the pivot of which is the sample node			
					pivot = select s from Conn:s
							where s.@sampled == False and s.@pivot == sample_node;
			
					# initialize the shortest distance
					@@dist = 0;
					# initialize the sum of the shortest distance from the sample node
					@@totalDist = 0;
					# initialize the map of shortest distance from other sample node
					@@cdist.clear();
			
					while vnode.size() > 0 do
						@@dist += 1;
	
						# initialize the size of non-sample node in the visiting node
						@@nonsample = 0;
	    
						# decide whether the sample node is within or outside the threshold radius from the pivot of the visiting node
						vnode = select t from vnode:s-(e_type)->:t
								where t.@visited == False
								post-accum
									t.@visited += True,
									if t.@sampled == True then
										@@cdist += (t->@@dist)  # record the distance between the sample node
									else
										# the size of non-sample nodes
										@@nonsample += 1,
										# the visiting node in L(u)
										case when t.@deltav > epsilon * @@dist / (1 - epsilon) - eps then
											t.@lavg += @@dist
										# the visiting node in HC(u)
										when t.@deltav < epsilon * @@dist /(1 + epsilon) then
											t.@hcsum += @@dist
										# if cannot decided, record the distance
										else
											t.@sdist = @@dist
										end
									end;
						# sum distance of the sample node
						@@totalDist += vnode.size() * @@dist;
				
						# decide whether the visiting node is within or outside the threshold radius from the pivot of which is the sample node
						pivot = select s from pivot:s
								post-accum
									if s.@deltav > epsilon * @@dist - eps then
										s.@lnum += vnode.size()   # the node num within the threshold radius
									else
										s.@hsum += @@nonsample * @@dist   # the sum distance of non-sample node outside the threshold radius
									end;
					end;
			
					sampleNode = {sample_node};
			
					# the sum distance of the sample node
					sampleNode = select s from sampleNode:s
							accum s.@totalDist += @@totalDist;			
			
					# calculate the node which has not been decided before
					post = select s from Conn:s
							where s.@sdist > 0
							post-accum
								if @@cdist.get(s.@pivot) * epsilon < s.@deltav + eps then
									s.@lavg += s.@sdist    # within the threshold radius
								else
									s.@hcsum += s.@sdist
								end;
							
					# clear the BFS visited accumulator and the distance recorded
					Conn = select s from Conn:s
							post-accum s.@visited = False, s.@sdist = 0;
          LOG(debug > 1,"one sample_node end");
  
  
				end;
				LOG(debug > 0, "BFS from sample node finished");
		
				# calculate closeness estimation for all nodes
				Conn = select s from Conn:s
						accum
							if s.@sampled == False then
								s.@totalDist = s.@lavg * s.@lnum + s.@hcsum + s.@hsum
							end
						post-accum 
							if wf == True then
								s.@closeness = ((cc_num-1) * 1.0 / (numVert-1)) * ((cc_num-1) * 1.0 /s.@totalDist)
							else
								s.@closeness = ((cc_num - 1) * 1.0) / (s.@totalDist * 1.0)
							end;

				LOG(debug > 0, "closeness_est end", Start.size());
				
        #clear the sample set
				@@sample.clear();
			end;
		end;
		LOG(debug > 0,"closeness finished");
    
    #output
		Start = select s from Start:s
				    post-accum
              if file_path != "" then
					      f.println(s,s.@closeness)
              end;
  
    if print_accum then
      print Start[Start.@closeness];
    end;
		LOG(debug > 0,"closeness output finished");
}
